# Transaction Ledger Service API & Database Requirements

## Summary
Create a minimal immutable transaction ledger microservice backed by PostgreSQL. Provide endpoints to create and retrieve transactions and to compute balances per user and per currency. Security and authentication are handled at the API Gateway level.

## Description
This service stores one record per financial movement. It must expose simple REST endpoints to create transactions, retrieve transactions (by id, by user, by user+currency) and compute balances (single currency or all currencies for a user). All data persisted in PostgreSQL. No user management, no deletion — corrections via new compensating transactions.

This service operates behind an API Gateway that handles authentication and authorization. The service trusts all incoming requests as they have been validated by the gateway layer.

## Acceptance Criteria
- POST /transactions persists a transaction and returns the stored record with generated `id` (UUID) and `timestamp`.
- Authentication and authorization are handled at the API Gateway level; the service trusts incoming requests.
- GET /transactions/{id} returns a single transaction or 404 if not found.
- GET /transactions?user_id={id} returns all transactions for a user ordered by timestamp desc.
- GET /transactions?user_id={id}&currency={c} returns filtered transactions for a user+currency.
- GET /balance?user_id={id}&currency={c} returns current balance for that user+currency.
- GET /balance?user_id={id} returns balances for all currencies the user has transactions in.
- Database is PostgreSQL; writes are ACID; transactions are immutable.
- Input validation returns 400 for invalid input; DB errors return 500.

## API Endpoints (contract)

### 1) Create transaction
- Method: POST
- Path: /transactions
- Security: Handled at API Gateway level (service trusts incoming requests)
- Request JSON:
  - `user_id` (string, required)
  - `amount` (decimal, required) — can be negative
  - `currency` (string, required) — lowercase code, e.g. `usd`, `brl`
- Success: 201 Created
- Response JSON:
  - `id` (uuid)
  - `user_id`
  - `amount`
  - `currency`
  - `timestamp` (ISO 8601 UTC)
- Errors:
  - 400 Bad Request — missing/invalid fields
  - 500 Internal Server Error — DB errors

### 2) Get transaction by id
- Method: GET
- Path: /transactions/{id}
- Success: 200 OK
- Response JSON: single transaction object (same shape as POST response)
- Errors:
  - 404 Not Found — id not found
  - 400 Bad Request — invalid uuid
  - 500 Internal Server Error

### 3) List transactions (by user, optional currency)
- Method: GET
- Path: /transactions
- Query parameters:
  - `user_id` (required)
  - `currency` (optional)
  - `limit` (optional, default 100)
  - `offset` (optional, default 0)
- Success: 200 OK
- Response JSON:
  - `transactions`: array of transaction objects ordered by `timestamp` desc
- Errors:
  - 400 Bad Request — missing user_id
  - 500 Internal Server Error

### 4) Get balance for user+currency
- Method: GET
- Path: /balance
- Query parameters:
  - `user_id` (required)
  - `currency` (required for this endpoint variation)
- Success: 200 OK
- Response JSON:
  - `user_id`
  - `currency`
  - `balance` (decimal) — SUM(amount)
- Errors:
  - 400 Bad Request — missing params
  - 500 Internal Server Error

### 5) Get all balances for user
- Method: GET
- Path: /balance
- Query parameters:
  - `user_id` (required)
- Success: 200 OK
- Response JSON:
  - `user_id`
  - `balances`: array of `{ "currency": string, "balance": decimal }`
- Errors:
  - 400 Bad Request
  - 500 Internal Server Error

## Data Model
- Transaction:
  - `id` UUID PRIMARY KEY (generated by service or DB)
  - `user_id` TEXT NOT NULL
  - `amount` NUMERIC(20,8) NOT NULL
  - `currency` TEXT NOT NULL
  - `timestamp` TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
- Business rules:
  - Immutable: never DELETE rows; corrections are new transactions.
  - No foreign keys to user table (service assumes user exists externally).

## Example SQL DDL (PostgreSQL)
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE transactions (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id text NOT NULL,
  amount numeric(20,8) NOT NULL,
  currency text NOT NULL,
  timestamp timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_transactions_user_currency_ts ON transactions(user_id, currency, timestamp DESC);
CREATE INDEX idx_transactions_user_ts ON transactions(user_id, timestamp DESC);
```

## Security Architecture
- **Authentication and Authorization**: Handled at the API Gateway level
- **Trust Model**: The ledger service trusts all incoming requests as they have been authenticated and authorized by the gateway
- **Network Security**: The service should be deployed in a private network, accessible only through the API Gateway
- **Benefits**:
  - Centralized security management at the gateway
  - Simplified service layer without middleware complexity
  - Easier to implement consistent security policies across multiple services
  - Gateway can handle rate limiting, authentication, and authorization uniformly

## Validation & Constraints
- `user_id` non-empty
- `amount` must be a valid decimal (reject NaN/Infinity)
- `currency` normalized to lowercase, max length 32
- Enforce not-null at DB level
- Service-level request validation returns 400 for violations

## Error Handling
- 400: invalid JSON, missing fields, invalid types
- 404: resource not found (transaction or no balances)
- 500: database or unexpected errors (log full error, return generic message)
- All errors should return a JSON body with `{ "error": "message" }`

## Non-Functional Requirements
- PostgreSQL for persistence and ACID guarantees
- Typical QPS initially low (10–20 users); design for easy horizontal scale
- Responses use JSON and ISO 8601 timestamps in UTC
- Logging: request id, user_id, endpoint, status, DB errors

## Implementation Steps (Jira Sub-tasks)
1. Design DB schema and create migration files
   - Add indexes for user lookups and currency aggregations
2. Scaffold service project with HTTP framework (REST)
3. Implement POST /transactions
   - Validate request
   - Insert into DB with generated UUID/timestamp
   - Return 201 with created record
4. Implement GET /transactions/{id}
   - Query by id, return 200 or 404
5. Implement GET /transactions (user + optional currency, limit/offset)
   - Support pagination parameters (limit/offset)
6. Implement GET /balance?user_id={}&currency={} and GET /balance?user_id={}
   - Use SQL aggregation: SUM(amount) GROUP BY currency for all balances
7. Add input validation & error mapping (400/404/500)
8. Add database connection pooling and config for PostgreSQL
9. Add integration tests:
   - Create transaction, retrieve by id, list by user, compute balance
10. Add simple logging and metrics (request count, latency, errors)
11. Add migration run step to deployment
12. Code review and merge

## Definition of Done
- All endpoints implemented and passing integration tests against a PostgreSQL test instance.
- Migrations included and applied in CI.
- Service deployed behind API Gateway for security.
- Basic validation and error responses implemented.
- `README` and `requirements.md` updated with API contract and examples.
- Code reviewed and merged.

## Notes / Future Stories
- Implement API Gateway with authentication (mutual TLS, service-to-service JWT, OAuth, or API tokens)
- Add request-level idempotency for writes
- Pagination + date-range filters for transaction listing
- Read replicas or cache for high read throughput of balances
- Add metadata/description or tags (as separate optional service)

## Quick examples and test notes
- Example curl:

```sh
curl -X POST http://localhost:8080/transactions \
  -H "Content-Type: application/json" \
  -d '{"user_id":"user-123","amount":"100.50","currency":"usd"}'
```

Note: In production, this service would be behind an API Gateway that handles authentication and only forwards authorized requests.



