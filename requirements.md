# Transaction Ledger Service API, DB & Minimal Security Requirements

## Summary
Create a minimal immutable transaction ledger microservice backed by PostgreSQL. Provide endpoints to create and retrieve transactions and to compute balances per user and per currency. Add a minimal security layer so that write operations (creating transactions) are accepted only from a single configured origin (internal HTTP source).

## Description
This service stores one record per financial movement. It must expose simple REST endpoints to create transactions, retrieve transactions (by id, by user, by user+currency) and compute balances (single currency or all currencies for a user). All data persisted in PostgreSQL. No user management, no deletion — corrections via new compensating transactions.

In addition, the service must apply a minimal security check: only accept POST /transactions requests when the request origin matches a single configured allowed origin (for example an internal HTTP gateway). Other requests should be rejected with 403 Forbidden.

## Acceptance Criteria
- POST /transactions persists a transaction and returns the stored record with generated `id` (UUID) and `timestamp`.
- Only requests with Origin header equal to configured `ALLOWED_ORIGIN` (or requests arriving from an internal-only network/gateway as configured) are allowed to create transactions. Unauthorized origins receive 403 Forbidden.
- GET endpoints remain readable for allowed clients (can be public or protected later); minimal requirement is write protection.
- GET /transactions/{id} returns a single transaction or 404 if not found.
- GET /transactions?user_id={id} returns all transactions for a user ordered by timestamp desc.
- GET /transactions?user_id={id}&currency={c} returns filtered transactions for a user+currency.
- GET /balance?user_id={id}&currency={c} returns current balance for that user+currency.
- GET /balance?user_id={id} returns balances for all currencies the user has transactions in.
- Database is PostgreSQL; writes are ACID; transactions are immutable.
- Input validation returns 400 for invalid input; DB errors return 500.

## API Endpoints (contract)

### 1) Create transaction
- Method: POST
- Path: /transactions
- Security: Allowed only when request `Origin` header equals configured `ALLOWED_ORIGIN` value (or when request passes internal gateway that sets a trusted header) — otherwise return 403.
- Request JSON:
  - `user_id` (string, required, must be a valid lowercase UUID format)
  - `amount` (decimal, required) — can be negative
  - `currency` (string, required, lowercase letters/numbers/underscores) — e.g. `usd`, `brl`, `loyalty_points`, `usd2024`
- Success: 201 Created
- Response JSON:
  - `id` (uuid, lowercase)
  - `user_id` (lowercase UUID)
  - `amount`
  - `currency` (lowercase)
  - `timestamp` (ISO 8601 UTC)
- Errors:
  - 400 Bad Request — missing/invalid fields, invalid UUID format (uppercase not accepted), invalid currency format
  - 403 Forbidden — origin not allowed
  - 500 Internal Server Error — DB errors

### 2) Get transaction by id
- Method: GET
- Path: /transactions/{id}
- Success: 200 OK
- Response JSON: single transaction object (same shape as POST response)
- Errors:
  - 404 Not Found — id not found
  - 400 Bad Request — invalid uuid format (must be lowercase)
  - 500 Internal Server Error

### 3) List transactions (by user, optional currency)
- Method: GET
- Path: /transactions
- Query parameters:
  - `user_id` (required, must be lowercase UUID format)
  - `currency` (optional, must be lowercase)
  - `limit` (optional, default 100)
  - `offset` (optional, default 0)
- Success: 200 OK
- Response JSON:
  - `transactions`: array of transaction objects ordered by `timestamp` desc
- Errors:
  - 400 Bad Request — missing user_id or invalid UUID format
  - 500 Internal Server Error

### 4) Get balance for user+currency
- Method: GET
- Path: /balance
- Query parameters:
  - `user_id` (required, must be lowercase UUID format)
  - `currency` (required for this endpoint variation, must be lowercase)
- Success: 200 OK
- Response JSON:
  - `user_id` (lowercase UUID)
  - `currency` (lowercase)
  - `balance` (decimal) — SUM(amount)
- Errors:
  - 400 Bad Request — missing params or invalid UUID format
  - 500 Internal Server Error

### 5) Get all balances for user
- Method: GET
- Path: /balance
- Query parameters:
  - `user_id` (required, must be lowercase UUID format)
- Success: 200 OK
- Response JSON:
  - `user_id` (lowercase UUID)
  - `balances`: array of `{ "currency": string, "balance": decimal }`
- Errors:
  - 400 Bad Request — missing user_id or invalid UUID format
  - 500 Internal Server Error

## Data Model
- Transaction:
  - `id` UUID PRIMARY KEY (generated by service or DB, lowercase format)
  - `user_id` TEXT NOT NULL (must be a valid lowercase UUID)
  - `amount` NUMERIC(20,8) NOT NULL
  - `currency` TEXT NOT NULL (lowercase letters, numbers, and underscores only)
  - `timestamp` TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
- Business rules:
  - Immutable: never DELETE rows; corrections are new transactions.
  - No foreign keys to user table (service assumes user exists externally).
  - UUIDs must be in lowercase format only.

## Example SQL DDL (PostgreSQL)
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE transactions (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id text NOT NULL,
  amount numeric(20,8) NOT NULL,
  currency text NOT NULL,
  timestamp timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_transactions_user_currency_ts ON transactions(user_id, currency, timestamp DESC);
CREATE INDEX idx_transactions_user_ts ON transactions(user_id, timestamp DESC);
```

## Minimal Security (required)
- Purpose: prevent unauthorized services or external clients from creating transactions.
- Strategy: Require that POST /transactions requests originate from a single configured origin value (`ALLOWED_ORIGIN`) or come through an internal gateway that sets a trusted header.
- Configuration:
  - Environment variable: `ALLOWED_ORIGIN` (example: `http://internal-gateway.local`)
  - Optionally allow a list (comma-separated) for staging vs prod, but default must be a single origin.
- Enforcement:
  - The service must check the `Origin` header (or a trusted custom header if running behind a gateway) on each write request.
  - If `Origin` header != `ALLOWED_ORIGIN` (string exact match), return 403 Forbidden with `{ "error": "origin not allowed" }`.
  - If `Origin` header is missing and the deployment expects internal requests only, reject with 403.
- Implementation notes:
  - Use a middleware in the HTTP stack that runs before write handlers.
  - Use exact string match (no regex) by default to keep it strict.
  - Ensure forwarding proxies preserve original `Origin` or gateway sets `X-Forwarded-Host`/`X-Internal-Source` and the middleware validates that trusted header instead.
  - Always prefer infrastructure controls (VPC, firewall, service mesh) over header checks for stronger guarantees; this header-based check is a minimal safeguard.

## Validation & Constraints
- `user_id` must be a valid UUID in lowercase format (e.g., "550e8400-e29b-41d4-a716-446655440000")
- Uppercase UUIDs are **not accepted** and will return 400 Bad Request
- `amount` must be a valid decimal (reject NaN/Infinity)
- `currency` must contain only lowercase letters, numbers, and underscores; max length 32
- Enforce not-null at DB level
- Service-level request validation returns 400 for violations

## Error Handling
- 400: invalid JSON, missing fields, invalid types, invalid UUID format (uppercase not accepted), invalid currency format
- 403: origin not allowed (for POST /transactions)
- 404: resource not found (transaction or no balances)
- 500: database or unexpected errors (log full error, return generic message)
- All errors should return a JSON body with `{ "error": "message" }`

## Non-Functional Requirements
- PostgreSQL for persistence and ACID guarantees
- Typical QPS initially low (10–20 users); design for easy horizontal scale
- Responses use JSON and ISO 8601 timestamps in UTC
- Logging: request id, user_id, endpoint, status, DB errors

## Implementation Steps (Jira Sub-tasks)
1. Design DB schema and create migration files
   - Add indexes for user lookups and currency aggregations
2. Scaffold service project with HTTP framework (REST)
3. Add configuration for `ALLOWED_ORIGIN` and add middleware that validates the `Origin` header for writes
4. Implement POST /transactions
   - Validate request
   - Check origin middleware
   - Insert into DB with generated UUID/timestamp
   - Return 201 with created record
5. Implement GET /transactions/{id}
   - Query by id, return 200 or 404
6. Implement GET /transactions (user + optional currency, limit/offset)
   - Support pagination parameters (limit/offset)
7. Implement GET /balance?user_id={}&currency={} and GET /balance?user_id={}
   - Use SQL aggregation: SUM(amount) GROUP BY currency for all balances
8. Add input validation & error mapping (400/403/404/500)
9. Add database connection pooling and config for PostgreSQL
10. Add integration tests:
   - Create transaction (allowed origin), create transaction (disallowed origin -> 403), retrieve by id, list by user, compute balance
11. Add simple logging and metrics (request count, latency, errors)
12. Add migration run step to deployment
13. Code review and merge

## Definition of Done
- All endpoints implemented and passing integration tests against a PostgreSQL test instance.
- Migrations included and applied in CI.
- Minimal origin-based write protection implemented and tested.
- Basic validation and error responses implemented.
- `README` and `requirements.md` updated with API contract and examples.
- Code reviewed and merged.

## Notes / Future Stories
- Replace header/origin-only check with stronger auth (mutual TLS, service-to-service JWT, mTLS, or API gateway token)
- Add owner/auth checks and request-level idempotency for writes
- Pagination + date-range filters for transaction listing
- Read replicas or cache for high read throughput of balances
- Add metadata/description or tags (as separate optional service)

## Quick examples and test notes
- Set env: `ALLOWED_ORIGIN=http://internal-gateway.local`
- Example curl (allowed):

```sh
curl -X POST https://ledger.internal/api/transactions \
  -H "Content-Type: application/json" \
  -H "Origin: http://internal-gateway.local" \
  -d '{"user_id":"550e8400-e29b-41d4-a716-446655440000","amount":"100.50","currency":"usd"}'
```

**Note:** `user_id` must be a valid lowercase UUID format.

- Example curl (disallowed origin -> will receive 403):

```sh
curl -X POST https://ledger.internal/api/transactions \
  -H "Content-Type: application/json" \
  -H "Origin: http://evil.example.com" \
  -d '{"user_id":"550e8400-e29b-41d4-a716-446655440000","amount":"100.50","currency":"usd"}'
```



