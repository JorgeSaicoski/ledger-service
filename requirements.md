# Transaction Ledger Service API, Database & Security Architecture

## Summary
Create a minimal immutable transaction ledger microservice backed by PostgreSQL. Provide endpoints to create and retrieve transactions and to compute balances per user and per currency. Security and authentication are handled at the API Gateway level.

## Description
This service stores one record per financial movement. It must expose simple REST endpoints to create transactions, retrieve transactions (by id, by user, by user+currency) and compute balances (single currency or all currencies for a user). All data persisted in PostgreSQL. No user management, no deletion — corrections via new compensating transactions.

This service operates behind an API Gateway that handles authentication and authorization. The service trusts all incoming requests as they have been validated by the gateway layer.

## Acceptance Criteria
- POST /transactions persists a transaction and returns the stored record with generated `id` (UUID) and `timestamp`.
- Authentication and authorization are handled at the API Gateway level; the service trusts incoming requests.
- GET /transactions/{id} returns a single transaction or 404 if not found.
- GET /transactions?user_id={id} returns all transactions for a user ordered by timestamp desc.
- GET /transactions?user_id={id}&currency={c} returns filtered transactions for a user+currency.
- GET /balance?user_id={id}&currency={c} returns current balance for that user+currency.
- GET /balance?user_id={id} returns balances for all currencies the user has transactions in.
- Database is PostgreSQL; writes are ACID; transactions are immutable.
- Input validation returns 400 for invalid input; DB errors return 500.

## API Endpoints (contract)

### 1) Create transaction
- Method: POST
- Path: /transactions
- Security: Handled at API Gateway level (service trusts incoming requests)
- Request JSON:
  - `user_id` (string, required, must be a valid lowercase UUID format)
  - `amount` (integer, required) — can be negative; stored in smallest currency unit
  - `currency` (string, required, lowercase letters/numbers/underscores) — e.g. `usd`, `brl`, `loyalty_points`, `usd2024`

- Success: 201 Created
- Response JSON:
  - `id` (uuid, lowercase)
  - `user_id` (lowercase UUID)
  - `amount`
  - `currency` (lowercase)
  - `timestamp` (ISO 8601 UTC)
- Errors:
  - 400 Bad Request — missing/invalid fields, invalid UUID format (uppercase not accepted), invalid currency format
  - 403 Forbidden — origin not allowed
  - 500 Internal Server Error — DB errors

### 2) Get transaction by id
- Method: GET
- Path: /transactions/{id}
- Success: 200 OK
- Response JSON: single transaction object (same shape as POST response)
- Errors:
  - 404 Not Found — id not found
  - 400 Bad Request — invalid uuid format (must be lowercase)
  - 500 Internal Server Error

### 3) List transactions (by user, optional currency)
- Method: GET
- Path: /transactions
- Query parameters:
  - `user_id` (required, must be lowercase UUID format)
  - `currency` (optional, must be lowercase)
  - `limit` (optional, default 100)
  - `offset` (optional, default 0)
- Success: 200 OK
- Response JSON:
  - `transactions`: array of transaction objects ordered by `timestamp` desc
- Errors:
  - 400 Bad Request — missing user_id or invalid UUID format
  - 500 Internal Server Error

### 4) Get balance for user+currency
- Method: GET
- Path: /balance
- Query parameters:
  - `user_id` (required, must be lowercase UUID format)
  - `currency` (required for this endpoint variation, must be lowercase)
- Success: 200 OK
- Response JSON:
  - `user_id` (lowercase UUID)
  - `currency` (lowercase)
  - `balance` (integer) — SUM(amount) in smallest currency unit
- Errors:
  - 400 Bad Request — missing params or invalid UUID format
  - 500 Internal Server Error

### 5) Get all balances for user
- Method: GET
- Path: /balance
- Query parameters:
  - `user_id` (required, must be lowercase UUID format)
- Success: 200 OK
- Response JSON:
  - `user_id` (lowercase UUID)
  - `balances`: array of `{ "currency": string, "balance": integer }`
- Errors:
  - 400 Bad Request — missing user_id or invalid UUID format
  - 500 Internal Server Error

## Data Model
- Transaction:
  - `id` UUID PRIMARY KEY (generated by service or DB, lowercase format)
  - `user_id` TEXT NOT NULL (must be a valid lowercase UUID)
  - `amount` BIGINT NOT NULL — stored in smallest currency unit (cents, centavos, pesos)
  - `currency` TEXT NOT NULL (lowercase letters, numbers, and underscores only)
  - `timestamp` TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
- Business rules:
  - Immutable: never DELETE rows; corrections are new transactions.
  - No foreign keys to user table (service assumes user exists externally).
  - UUIDs must be in lowercase format only.
  - Integer amounts avoid floating-point precision issues.

## Example SQL DDL (PostgreSQL)
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE transactions (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id text NOT NULL,
  amount bigint NOT NULL,
  currency text NOT NULL,
  timestamp timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_transactions_user_currency_ts ON transactions(user_id, currency, timestamp DESC);
CREATE INDEX idx_transactions_user_ts ON transactions(user_id, timestamp DESC);
```

## Security Architecture
- **Authentication and Authorization**: Handled at the API Gateway level
- **Trust Model**: The ledger service trusts all incoming requests as they have been authenticated and authorized by the gateway
- **Network Security**: The service should be deployed in a private network, accessible only through the API Gateway
- **Benefits**:
  - Centralized security management at the gateway
  - Simplified service layer without middleware complexity
  - Easier to implement consistent security policies across multiple services
  - Gateway can handle rate limiting, authentication, and authorization uniformly

## Validation & Constraints
- `user_id` must be a valid UUID in lowercase format (e.g., "550e8400-e29b-41d4-a716-446655440000")
- Uppercase UUIDs are **not accepted** and will return 400 Bad Request
- `amount` must be a valid integer (reject decimals/NaN/Infinity)
- `currency` must contain only lowercase letters, numbers, and underscores; max length 32
- Enforce not-null at DB level
- Service-level request validation returns 400 for violations

## Error Handling
- 400: invalid JSON, missing fields, invalid types, invalid UUID format (uppercase not accepted), invalid currency format
- 404: resource not found (transaction or no balances)
- 500: database or unexpected errors (log full error, return generic message)
- All errors should return a JSON body with `{ "error": "message" }`

## Non-Functional Requirements
- PostgreSQL for persistence and ACID guarantees
- Typical QPS initially low (10–20 users); design for easy horizontal scale
- Responses use JSON and ISO 8601 timestamps in UTC
- Logging: request id, user_id, endpoint, status, DB errors

## Implementation Steps (Jira Sub-tasks)
1. Design DB schema and create migration files
   - Add indexes for user lookups and currency aggregations
2. Scaffold service project with HTTP framework (REST)
3. Implement POST /transactions
   - Validate request
   - Insert into DB with generated UUID/timestamp
   - Return 201 with created record
4. Implement GET /transactions/{id}
   - Query by id, return 200 or 404
5. Implement GET /transactions (user + optional currency, limit/offset)
   - Support pagination parameters (limit/offset)
6. Implement GET /balance?user_id={}&currency={} and GET /balance?user_id={}
   - Use SQL aggregation: SUM(amount) GROUP BY currency for all balances
7. Add input validation & error mapping (400/404/500)
8. Add database connection pooling and config for PostgreSQL
9. Add integration tests:
   - Create transaction, retrieve by id, list by user, compute balance
10. Add simple logging and metrics (request count, latency, errors)
11. Add migration run step to deployment
12. Code review and merge

## Definition of Done
- All endpoints implemented and passing integration tests against a PostgreSQL test instance.
- Migrations included and applied in CI.
- Service deployed behind API Gateway for security.
- Basic validation and error responses implemented.
- `README` and `requirements.md` updated with API contract and examples.
- Code reviewed and merged.

## Notes / Future Stories
- Implement API Gateway with authentication (mutual TLS, service-to-service JWT, OAuth, or API tokens)
- Add request-level idempotency for writes
- Pagination + date-range filters for transaction listing
- Read replicas or cache for high read throughput of balances
- Add metadata/description or tags (as separate optional service)

## Quick examples and test notes
- Example curl:

```sh
curl -X POST http://localhost:8080/transactions \
  -H "Content-Type: application/json" \
  -d '{"user_id":"550e8400-e29b-41d4-a716-446655440000","amount":"100.50","currency":"usd"}'
```
*Note: Amount 10050 represents $100.50 in cents*

**Note:** `user_id` must be a valid lowercase UUID format.

*Note: In production, this service would be behind an API Gateway that handles authentication and only forwards authorized requests.



